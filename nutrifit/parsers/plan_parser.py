"""Parser for converting LLM-generated plans into structured data."""

import re
import uuid
from datetime import date, timedelta
from typing import Optional
from dataclasses import dataclass

from nutrifit.models.plan import MealPlan, DailyMealPlan, WorkoutPlan, DailyWorkoutPlan
from nutrifit.models.recipe import Recipe, Ingredient, NutritionInfo
from nutrifit.models.workout import Workout, Exercise, MuscleGroup, ExerciseType, Equipment
from nutrifit.models.user import UserProfile


@dataclass
class ParsedMeal:
    """Temporary structure for parsed meal data."""
    meal_type: str  # breakfast, lunch, dinner, snack
    name: str
    calories: int
    protein: int
    carbs: int
    fat: int


@dataclass
class ParsedExercise:
    """Temporary structure for parsed exercise data."""
    name: str
    sets: Optional[int] = None
    reps: Optional[int] = None
    duration: Optional[int] = None  # minutes
    rest: Optional[int] = None  # seconds


class PlanParser:
    """Parse LLM-generated plans into structured data."""
    
    # Regex patterns for meal extraction
    MEAL_PATTERN = re.compile(
        r'(?:ðŸ³|ðŸ¥—|ðŸ½ï¸|ðŸŽ)\s*(\w+):\s*([^(~\n]+)',
        re.IGNORECASE
    )
    MACRO_PATTERN = re.compile(
        r'Protein:\s*(\d+)g[,\s]*Carbs:\s*(\d+)g[,\s]*Fat:\s*(\d+)g',
        re.IGNORECASE
    )
    CALORIES_ONLY_PATTERN = re.compile(r'~?(\d+)\s*kcal', re.IGNORECASE)
    DAY_PATTERN = re.compile(r'\*\*Day\s+(\d+)', re.IGNORECASE)
    
    # Regex patterns for exercise extraction
    EXERCISE_LINE_PATTERN = re.compile(r'-\s*([^:]+):\s*([^\n]+)')
    SETS_REPS_PATTERN = re.compile(r'(\d+)\s*sets?\s*[Ã—x]\s*(\d+)\s*reps?', re.IGNORECASE)
    DURATION_PATTERN = re.compile(r'(\d+)\s*(?:minutes?|mins?)', re.IGNORECASE)
    REST_PATTERN = re.compile(r'Rest:\s*(\d+)s', re.IGNORECASE)
    
    def __init__(self):
        """Initialize the parser."""
        pass
    
    def parse_meal_plan(self, llm_text: str, user_profile: UserProfile) -> MealPlan:
        """Parse LLM meal plan text into MealPlan object.
        
        Args:
            llm_text: The LLM-generated meal plan text
            user_profile: User's profile for context
            
        Returns:
            MealPlan object with structured data
            
        Raises:
            ValueError: If parsing fails completely
        """
        try:
            daily_plans = []
            days = self._extract_days(llm_text)
            
            start_date = date.today()
            
            if not days:
                # Try to parse as single-day plan
                parsed_meals = self._extract_meals_from_text(llm_text)
                if parsed_meals:
                    daily_plan = self._create_daily_meal_plan(parsed_meals, start_date)
                    daily_plans.append(daily_plan)
                else:
                    raise ValueError("Could not extract any meals from the plan. The plan may not be in the expected format.")
            else:
                # Multi-day plan
                for day_num, day_text in days.items():
                    day_date = start_date + timedelta(days=day_num - 1)
                    parsed_meals = self._extract_meals_from_text(day_text)
                    if parsed_meals:
                        daily_plan = self._create_daily_meal_plan(parsed_meals, day_date)
                        daily_plans.append(daily_plan)
                    else:
                        # Log warning but continue with other days
                        print(f"[PARSER WARNING] No meals found for day {day_num}, skipping")
            
            if not daily_plans:
                raise ValueError("No meals could be extracted from the plan. Please try regenerating with more specific meal details.")
            
            # Create meal plan
            plan_id = str(uuid.uuid4())
            plan_name = f"AI Generated Meal Plan - {start_date.isoformat()}"
            end_date = start_date + timedelta(days=len(daily_plans) - 1)
            
            return MealPlan(
                id=plan_id,
                name=plan_name,
                start_date=start_date,
                end_date=end_date,
                daily_plans=daily_plans,
                target_calories_per_day=user_profile.daily_calorie_target or 2000,
                notes="Generated by AI Chat",
                source="ai_chat"
            )
        
        except ValueError:
            # Re-raise ValueError with original message
            raise
        except Exception as e:
            # Wrap unexpected errors in ValueError with helpful message
            raise ValueError(f"Unexpected error while parsing meal plan: {str(e)}")
    
    def parse_workout_plan(self, llm_text: str, user_profile: UserProfile) -> WorkoutPlan:
        """Parse LLM workout plan text into WorkoutPlan object.
        
        Args:
            llm_text: The LLM-generated workout plan text
            user_profile: User's profile for context
            
        Returns:
            WorkoutPlan object with structured data
            
        Raises:
            ValueError: If parsing fails completely
        """
        try:
            daily_plans = []
            days = self._extract_workout_days(llm_text)
            
            if not days:
                raise ValueError("Could not extract any workout days from the plan. The plan may not be in the expected format.")
            
            start_date = date.today()
            for day_num, (day_name, day_text) in enumerate(days.items(), 1):
                day_date = start_date + timedelta(days=day_num - 1)
                
                # Check if it's a rest day
                is_rest_day = "rest" in day_name.lower() or "recovery" in day_text.lower()
                
                if is_rest_day:
                    daily_plan = DailyWorkoutPlan(
                        date=day_date,
                        workouts=[],
                        is_rest_day=True,
                        notes=day_name
                    )
                    daily_plans.append(daily_plan)
                else:
                    exercises = self._extract_exercises_from_text(day_text)
                    if exercises:
                        workout = self._create_workout_from_exercises(
                            day_name, exercises, day_text
                        )
                        daily_plan = DailyWorkoutPlan(
                            date=day_date,
                            workouts=[workout],
                            is_rest_day=False,
                            notes=""
                        )
                        daily_plans.append(daily_plan)
                    else:
                        # Log warning but continue with other days
                        print(f"[PARSER WARNING] No exercises found for {day_name}, skipping")
            
            if not daily_plans:
                raise ValueError("No workout days could be extracted from the plan. Please try regenerating with more specific exercise details.")
            
            # Create workout plan
            plan_id = str(uuid.uuid4())
            plan_name = f"AI Generated Workout Plan - {start_date.isoformat()}"
            end_date = start_date + timedelta(days=len(daily_plans) - 1)
            workout_days_count = sum(1 for dp in daily_plans if not dp.is_rest_day)
            
            return WorkoutPlan(
                id=plan_id,
                name=plan_name,
                start_date=start_date,
                end_date=end_date,
                daily_plans=daily_plans,
                workout_days_per_week=workout_days_count,
                notes="Generated by AI Chat",
                source="ai_chat"
            )
        
        except ValueError:
            # Re-raise ValueError with original message
            raise
        except Exception as e:
            # Wrap unexpected errors in ValueError with helpful message
            raise ValueError(f"Unexpected error while parsing workout plan: {str(e)}")
    
    def _extract_days(self, text: str) -> dict:
        """Extract day sections from text.
        
        Returns:
            Dict mapping day number to day text
        """
        days = {}
        lines = text.split('\n')
        current_day = None
        current_text = []
        
        for line in lines:
            day_match = self.DAY_PATTERN.search(line)
            if day_match:
                # Save previous day
                if current_day is not None:
                    days[current_day] = '\n'.join(current_text)
                # Start new day
                current_day = int(day_match.group(1))
                current_text = [line]
            elif current_day is not None:
                current_text.append(line)
        
        # Save last day
        if current_day is not None:
            days[current_day] = '\n'.join(current_text)
        
        return days
    
    def _extract_meals_from_text(self, text: str) -> list[ParsedMeal]:
        """Extract meal information from text.
        
        Returns:
            List of ParsedMeal objects
        """
        meals = []
        lines = text.split('\n')
        
        for line in lines:
            meal_match = self.MEAL_PATTERN.search(line)
            if meal_match:
                meal_type = meal_match.group(1).lower()
                meal_name_raw = meal_match.group(2).strip()
                
                # Clean up meal name - remove everything after (~
                if '(' in meal_name_raw:
                    meal_name = meal_name_raw[:meal_name_raw.index('(')].strip()
                else:
                    meal_name = meal_name_raw
                
                # Extract calories
                calories = 0
                cal_match = self.CALORIES_ONLY_PATTERN.search(line)
                if cal_match:
                    calories = int(cal_match.group(1))
                
                # Try to extract macros from the same line
                macro_match = self.MACRO_PATTERN.search(line)
                if macro_match:
                    protein = int(macro_match.group(1))
                    carbs = int(macro_match.group(2))
                    fat = int(macro_match.group(3))
                else:
                    # Estimate macros if not provided
                    protein, carbs, fat = self._estimate_macros(calories)
                
                meals.append(ParsedMeal(
                    meal_type=meal_type,
                    name=meal_name,
                    calories=calories,
                    protein=protein,
                    carbs=carbs,
                    fat=fat
                ))
        
        return meals

    def _extract_workout_days(self, text: str) -> dict:
        """Extract workout day sections from text.
        
        Returns:
            Dict mapping day name to day text
        """
        days = {}
        lines = text.split('\n')
        current_day_name = None
        current_text = []
        
        # Pattern for workout day headers like "**Day 1 - Upper Body:**"
        day_header_pattern = re.compile(r'\*\*Day\s+\d+\s*[-â€“]\s*([^:*]+)', re.IGNORECASE)
        
        for line in lines:
            day_match = day_header_pattern.search(line)
            if day_match:
                # Save previous day
                if current_day_name is not None:
                    days[current_day_name] = '\n'.join(current_text)
                # Start new day
                current_day_name = day_match.group(1).strip()
                current_text = [line]
            elif current_day_name is not None:
                current_text.append(line)
        
        # Save last day
        if current_day_name is not None:
            days[current_day_name] = '\n'.join(current_text)
        
        return days
    
    def _extract_exercises_from_text(self, text: str) -> list[ParsedExercise]:
        """Extract exercise information from text.
        
        Returns:
            List of ParsedExercise objects
        """
        exercises = []
        lines = text.split('\n')
        
        for line in lines:
            # Skip lines that are day headers or empty
            if line.strip().startswith('**') or not line.strip():
                continue
            
            # Look for exercise lines starting with "-"
            if not line.strip().startswith('-'):
                continue
                
            exercise_match = self.EXERCISE_LINE_PATTERN.search(line)
            if exercise_match:
                exercise_name = exercise_match.group(1).strip()
                exercise_details = exercise_match.group(2).strip()
                
                # Extract sets and reps
                sets_reps_match = self.SETS_REPS_PATTERN.search(exercise_details)
                sets = int(sets_reps_match.group(1)) if sets_reps_match else None
                reps = int(sets_reps_match.group(2)) if sets_reps_match else None
                
                # Extract duration
                duration_match = self.DURATION_PATTERN.search(exercise_details)
                duration = int(duration_match.group(1)) if duration_match else None
                
                # Extract rest period
                rest_match = self.REST_PATTERN.search(exercise_details)
                rest = int(rest_match.group(1)) if rest_match else 60  # Default 60s
                
                exercises.append(ParsedExercise(
                    name=exercise_name,
                    sets=sets,
                    reps=reps,
                    duration=duration,
                    rest=rest
                ))
        
        return exercises
    
    def _create_daily_meal_plan(self, parsed_meals: list[ParsedMeal], day_date: date) -> DailyMealPlan:
        """Create a DailyMealPlan from parsed meals.
        
        Args:
            parsed_meals: List of ParsedMeal objects
            day_date: Date for the meal plan
            
        Returns:
            DailyMealPlan object
        """
        breakfast = None
        lunch = None
        dinner = None
        snacks = []
        
        for pm in parsed_meals:
            recipe = self._create_recipe_from_parsed_meal(pm)
            
            if pm.meal_type == "breakfast":
                breakfast = recipe
            elif pm.meal_type == "lunch":
                lunch = recipe
            elif pm.meal_type == "dinner":
                dinner = recipe
            elif pm.meal_type == "snack":
                snacks.append(recipe)
        
        return DailyMealPlan(
            date=day_date,
            breakfast=breakfast,
            lunch=lunch,
            dinner=dinner,
            snacks=snacks,
            notes="AI Generated"
        )
    
    def _create_recipe_from_parsed_meal(self, parsed_meal: ParsedMeal) -> Recipe:
        """Create a Recipe object from a ParsedMeal.
        
        Args:
            parsed_meal: ParsedMeal object
            
        Returns:
            Recipe object
        """
        nutrition = NutritionInfo(
            calories=parsed_meal.calories,
            protein_g=float(parsed_meal.protein),
            carbs_g=float(parsed_meal.carbs),
            fat_g=float(parsed_meal.fat)
        )
        
        # Try to extract ingredients from the meal name
        ingredients = self._extract_ingredients_from_meal_name(parsed_meal.name)
        
        return Recipe(
            id=str(uuid.uuid4()),
            name=parsed_meal.name,
            description=f"AI generated {parsed_meal.meal_type}",
            ingredients=ingredients,
            instructions=["Prepare as described by AI"],
            nutrition=nutrition,
            prep_time_minutes=15,
            cook_time_minutes=20,
            servings=1,
            meal_type=parsed_meal.meal_type,
            tags=["ai_generated"],
            dietary_info=[],
            difficulty="medium"
        )
    
    def _extract_ingredients_from_meal_name(self, meal_name: str) -> list[Ingredient]:
        """Extract likely ingredients from a meal name.
        
        Args:
            meal_name: Name of the meal (e.g., "Grilled Chicken with Rice")
            
        Returns:
            List of Ingredient objects
        """
        # Common ingredient keywords to look for in meal names
        ingredient_keywords = {
            # Proteins
            "chicken": ("chicken", 150, "g"),
            "beef": ("beef", 150, "g"),
            "steak": ("steak", 200, "g"),
            "salmon": ("salmon", 150, "g"),
            "fish": ("fish", 150, "g"),
            "shrimp": ("shrimp", 150, "g"),
            "turkey": ("turkey", 150, "g"),
            "pork": ("pork", 150, "g"),
            "lamb": ("lamb", 150, "g"),
            "tofu": ("tofu", 150, "g"),
            "eggs": ("eggs", 2, "large"),
            "egg": ("eggs", 2, "large"),
            # Grains
            "rice": ("rice", 100, "g"),
            "pasta": ("pasta", 100, "g"),
            "quinoa": ("quinoa", 100, "g"),
            "oatmeal": ("oats", 50, "g"),
            "oats": ("oats", 50, "g"),
            "bread": ("bread", 2, "slices"),
            # Vegetables
            "salad": ("mixed greens", 100, "g"),
            "broccoli": ("broccoli", 100, "g"),
            "spinach": ("spinach", 100, "g"),
            "kale": ("kale", 100, "g"),
            "cauliflower": ("cauliflower", 100, "g"),
            "asparagus": ("asparagus", 100, "g"),
            "sweet potato": ("sweet potato", 150, "g"),
            "potato": ("potato", 150, "g"),
            "avocado": ("avocado", 1, "medium"),
            "tomato": ("tomato", 100, "g"),
            # Dairy
            "yogurt": ("Greek yogurt", 150, "g"),
            "cheese": ("cheese", 50, "g"),
            # Other
            "smoothie": ("mixed fruits", 200, "g"),
            "soup": ("vegetable broth", 300, "ml"),
            "wrap": ("whole wheat tortilla", 1, "large"),
            "bowl": ("mixed vegetables", 150, "g"),
        }
        
        ingredients = []
        meal_lower = meal_name.lower()
        
        for keyword, (ing_name, quantity, unit) in ingredient_keywords.items():
            if keyword in meal_lower:
                ingredients.append(Ingredient(
                    name=ing_name,
                    quantity=float(quantity),
                    unit=unit,
                    optional=False
                ))
        
        # If no ingredients found, use the meal name as a single ingredient
        if not ingredients:
            ingredients.append(Ingredient(
                name=meal_name,
                quantity=1.0,
                unit="serving",
                optional=False
            ))
        
        return ingredients
    
    def _create_workout_from_exercises(
        self, 
        workout_name: str, 
        parsed_exercises: list[ParsedExercise],
        day_text: str
    ) -> Workout:
        """Create a Workout object from parsed exercises.
        
        Args:
            workout_name: Name of the workout
            parsed_exercises: List of ParsedExercise objects
            day_text: Original text for the day
            
        Returns:
            Workout object
        """
        exercises = []
        total_duration = 0
        
        for pe in parsed_exercises:
            exercise = Exercise(
                id=str(uuid.uuid4()),
                name=pe.name,
                description=f"AI generated exercise",
                muscle_groups=[MuscleGroup.FULL_BODY],  # Default, could be improved
                exercise_type=ExerciseType.STRENGTH,  # Default
                equipment_needed=[],
                sets=pe.sets or 3,
                reps=pe.reps,
                duration_seconds=pe.duration * 60 if pe.duration else None,
                rest_seconds=pe.rest or 60,
                difficulty="intermediate",
                instructions=[],
                tips=[],
                calories_per_minute=5.0
            )
            exercises.append(exercise)
            
            # Estimate duration
            if pe.duration:
                total_duration += pe.duration
            elif pe.sets and pe.reps:
                # Estimate: 3 seconds per rep + rest time
                total_duration += (pe.sets * pe.reps * 3 + pe.sets * (pe.rest or 60)) // 60
        
        return Workout(
            id=str(uuid.uuid4()),
            name=workout_name,
            description=f"AI generated workout",
            exercises=exercises,
            workout_type="strength",  # Default
            difficulty="intermediate",
            duration_minutes=max(total_duration, 30),  # At least 30 minutes
            target_muscle_groups=[MuscleGroup.FULL_BODY],
            tags=["ai_generated"],
            warmup_minutes=5,
            cooldown_minutes=5
        )
    
    def _estimate_macros(self, calories: int) -> tuple[int, int, int]:
        """Estimate macros from calories using standard ratios.
        
        Uses a balanced macro split:
        - Protein: 30% of calories (4 cal/g)
        - Carbs: 40% of calories (4 cal/g)
        - Fat: 30% of calories (9 cal/g)
        
        Args:
            calories: Total calories
            
        Returns:
            Tuple of (protein_g, carbs_g, fat_g)
        """
        if calories == 0:
            return (0, 0, 0)
        
        protein_g = int((calories * 0.30) / 4)
        carbs_g = int((calories * 0.40) / 4)
        fat_g = int((calories * 0.30) / 9)
        
        return (protein_g, carbs_g, fat_g)
